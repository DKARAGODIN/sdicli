# SDICLI

Структурная диаграмма: [link](https://drive.google.com/file/d/1oOyFDbzb-k4jFylwcKNzB57CGmUAdjKh/view?usp=sharing)

![](diagram.png)

## Общее описание системы

Основной класс Interpreter считывает команды, которые вводит пользователь. 

Считанную команду он передает Scanner'у, который выполняет подстановку, а затем разбивает эту строку на лексемы. 

Полученные лексемы передаются Parser'у, который анализирует их и формирует команды с их аргументами, либо создает переменную окружения. 

Сформированные команды передаются на выполнение Runner'у, который запускает их в порядке конвеера. Interpreter выводит пользователю результат выполнения Runner'а: это либо вывод последней команды, либо сообщение об ошибке.

## Scanner
Анализирует текст исходной команды в два этапа
1. Первый проход сканера (метод *substitute*) модифицирует исходную строку  
 Выполняет подстановки переменных вида $x. Информация о содержимом переменных хранится в статическом классе окружения (*Enviroment*). Если переменной в окружении нет, то вместо нее будет подставлена пустая строка.    
Подстановки не выполняются, только если участок текста находится в одинарных кавычках (full quoting) на самом общем уровне вложенности (т.е. имеет вид \`...\`  и не находится внутри двойных кавычек).

2. Второй проход сканера (метод *scan*): разбиваем исходный текст запроса на лексемы. Возвращает список лексем, сохраняя их исходный порядок. Каждая лексема имеет свой тип. Лексемы типа *str* дополнительно хранят содержимое исходной строки. Анализ лексем достаточно простой, поэтому для определения их типа достаточно регулярных выражений.

### Лексемы
* *str* - строка произвольного формата. Объединяет символы, заключенные в двойные или ординарные скобки.  
* *id* является производной от *str*, определяет имя переменной в операции присваивания. Может содержать только цифры, буквы, нижнее подчеркивание и начинается не с цифры. 
* *assign* - знак равенства (=)
* *pipe* - знак вертикальной черты (|)

## Parser

Парсер преобразует набор лексем в команды по следующим правила (в порядке убывания приоритета)  
 * Если вторая от начала лексема - это *assign*: проверяем, чтобы первая была *id* (имя переменной), а третья - *str* (значение переменной). Если нет - ошибка операции присваивания.   
 Иначе парсер заносит имя переменной и ее значение в *Enviroment*. Все лексемы, стоящие после значения переменной, игнорируются.   

 * Если первая лексема *str* - она считается именем команды. Все лексемы после нее и до первого *pipe* считаем аргументами. Если лексемы закончились (или очередная лексема - это *pipe*) - создаем объект команды, соответствующий ее имени (класс *Command*) и передаем в нее выделенные аргументы (метод *setArgs*).  
 
 Для каждой из базовых команд (см. список ниже) существует своя имплементация *Command*. Для неизвестных команд - общая, которая сохраняет имя команды и список аргументов. Такие команды вызываются как внешние. Результат выполнения парсера - список объектов обнаруженных команд.

## Runner

Runner получает на вход список команд. Все команды реализуют одинаковый интерфейс. Все команды имеют в качестве поля список аргументов и имеют
метод run. Метод run принимает абстрактный ридер (далее - входящий ридер) и возвращает абстрактный ридер (далее - исходящий ридер), 
чтобы можно было строить цепочки. Также этот метод декларирует то что он выбрасывает исключение.

Использование абстрактных ридеров в качестве параметров позволяет менять возможные реализации. 
Мы можем читать или писать данные по сети, из файлов, из объектов. Для нашей программы это будет неважно.

Все команды реализуют логику работы в методе run. Команды могут использовать данные полученные через аргументы, а могут 
не использовать. Команды могут использовать информацию из входящего ридера, а могут не использовать. Эти детали 
зависят от реализации конкретной команды. Главное, что все команды возвращают исходящий ридер. Из этого ридера можно будет 
считывать результаты работы команды.

Runner проверяет результативность выполнения команды. Если в ходе работы команды было выброшено исключение, то оно 
перехватывается и об этом сообщается пользователю. Последующие команды не выполняются.

После выполнения всех команд Runner считывает информацию из последнего исходящего ридера, и отправляет ее на консоль.

## Список базовых команд

### EchoCommand

Echo игнорирует все что поступило во входящем ридере. Выводит в исходящий ридер все свои аргументы через один пробел.

### CatCommand

Cat выводит содержимое файлов, которые указаны в аргументах. 
Если файлы не указаны, тогда команда перенаправляет содержимое входящего ридера в исходящий ридер.

### WcCommand

Wc выводит количество строк, слов и байт в файлах, которые указаны в аргументах. 
Если файлы не указаны, тогда команда выводит количество строк, слов и байт в данных входящего ридера.

### PwdCommand

Pwd выводит полный путь текущей директории. Игнорирует данные во входящем ридере и игнорирует аргументы.

### ExecuteCommand

Execute выполняет произвольную команду. На вход команде передаются аргументы. Стандартный потоки входа читает данные из
входящего ридера, а стандартный поток вывода записывает данные в исходящий ридер.

### ExitCommand

Команда завершает работу интерпретатора.

 ## Разделение на этапы
 * Первый проход сканера реализует только подстановку, без какой-либо дополнительной логики. Поэтому этот метод будет добавлен только на втором этапе без существенного изменения существующего кода.
 * В результате работы парсера на базовом этапе будем анализировать только первую команду, игнорируя лексемы после pipe. Итоговый список методов будет состоять из одного элемента.  
 * Механизмы определения потоков ввода/вывода у команд будут реализованы, но проинициализированы стандартными потоками. 

## Команда 
* Карагодин Дмитрий
* Бачище Ольга
* Шушаков Даниил